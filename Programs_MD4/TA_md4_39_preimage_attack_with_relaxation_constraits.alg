//
// New MD4-39 Preimage Attack with K = 0
//

__in bit M[16][32];
__in bit S[31];
__out bit Hash[4][32];

bit A[32] = 0x67452301;
bit B[32] = 0xEFCDAB89;
bit C[32] = 0x98BADCFE;
bit D[32] = 0x10325476;



bit F(bit X[32], bit Y[32], bit Z[32])
{
	return (X&Y)|(!X&Z);
}

bit G(bit X[32], bit Y[32], bit Z[32])
{
	return X&Y | X&Z | Y&Z;
}

bit H(bit X[32], bit Y[32], bit Z[32])
{
	return X^Y^Z;
}

// Round 1, (a + F(b, c, d) + M) <<< s
bit FF(bit a[32], bit b[32], bit c[32], bit d[32], bit M[32], int s)
{
	a = sum(sum(a, F(b, c, d), 32), M, 32);
	return (a <<< s);
}

// Round 2, (a + G(b, c, d) + M + 0x5A827999) <<< s
bit GG(bit a[32], bit b[32], bit c[32], bit d[32], bit M[32], int s)
{
	a = sum(sum(sum(a, G(b, c, d), 32), M, 32), 0x5A827999, 32);
	return (a <<< s);
}

// Round 3, (a + H(b, c, d) + M + 0x6ED9EBA1) <<< s
bit HH(bit a[32], bit b[32], bit c[32], bit d[32], bit M[32], int s)
{
	a = sum(sum(sum(a, H(b, c, d), 32), M, 32), 0x6ED9EBA1, 32);
	return (a <<< s);
}

void main()
{
	bit a[32] = A;
	bit b[32] = B;
	bit c[32] = C;
	bit d[32] = D;
	int i;
	
	// Steps from 1--16
	a = FF(a, b, c, d, M[0], 3);
	d = FF(d, a, b, c, M[1], 7);
	c = FF(c, d, a, b, M[2], 11);
	b = FF(b, c, d, a, M[3], 19);

	a = FF(a, b, c, d, M[4], 3);   
	d = FF(d, a, b, c, M[5], 7);   
	c = FF(c, d, a, b, M[6], 11);  
	b = FF(b, c, d, a, M[7], 19);  
	
	// implication encoding: S[0] -> !a, S[1] -> !d, S[2] -> !c, S[3] -> !b
	for(i = 0; i < 32; i = i + 1)
	{
		assert(!S[0] | !a[i]);
		assert(!S[1] | !d[i]);
		assert(!S[2] | !c[i]);
		assert(!S[3] | !b[i]);
	}

	a = FF(a, b, c, d, M[8], 3);   
	d = FF(d, a, b, c, M[9], 7);   
	c = FF(c, d, a, b, M[10], 11); 
	b = FF(b, c, d, a, M[11], 19); 

	// implication encoding: S[4] -> !a, S[5] -> !d, S[6] -> !c, S[7] -> !b
	for(i = 0; i < 32; i = i + 1)
	{
		assert(!S[4] | !a[i]);
		assert(!S[5] | !d[i]);
		assert(!S[6] | !c[i]);
		assert(!S[7] | !b[i]);
	}

	a = FF(a, b, c, d, M[12], 3); 
	d = FF(d, a, b, c, M[13], 7); 
	c = FF(c, d, a, b, M[14], 11); 
	b = FF(b, c, d, a, M[15], 19); 

	// implication encoding: S[8] -> !a, S[9] -> !d, S[10] -> !c, S[11] -> !b
	for(i = 0; i < 32; i = i + 1)
	{
		assert(!S[8] | !a[i]);
		assert(!S[9] | !d[i]);
		assert(!S[10] | !c[i]);
		assert(!S[11] | !b[i]);
	}

	// Steps from 17--32
	a = GG(a, b, c, d, M[0], 3); 
	d = GG(d, a, b, c, M[4], 5); 
	c = GG(c, d, a, b, M[8], 9); 
	b = GG(b, c, d, a, M[12], 13); 

	// implication encoding: S[12] -> !a, S[13] -> !d, S[14] -> !c, S[15] -> !b
	for(i = 0; i < 32; i = i + 1)
	{
		assert(!S[12] | !a[i]);
		assert(!S[13] | !d[i]);
		assert(!S[14] | !c[i]);
		assert(!S[15] | !b[i]);
	}

	a = GG(a, b, c, d, M[1], 3); 
	d = GG(d, a, b, c, M[5], 5); 
	c = GG(c, d, a, b, M[9], 9); 
	b = GG(b, c, d, a, M[13], 13); 

	// implication encoding: S[16] -> !a, S[17] -> !d, S[18] -> !c, S[19] -> !b
	for(i = 0; i < 32; i = i + 1)
	{
		assert(!S[16] | !a[i]);
		assert(!S[17] | !d[i]);
		assert(!S[18] | !c[i]);
		assert(!S[19] | !b[i]);
	}

	a = GG(a, b, c, d, M[2], 3);  
	d = GG(d, a, b, c, M[6], 5);  
	c = GG(c, d, a, b, M[10], 9); 
	b = GG(b, c, d, a, M[14], 13); 

	// implication encoding: S[20] -> !a, S[21] -> !d, S[22] -> !c, S[23] -> !b
	for(i = 0; i < 32; i = i + 1)
	{
		assert(!S[20] | !a[i]);
		assert(!S[21] | !d[i]);
		assert(!S[22] | !c[i]);
		assert(!S[23] | !b[i]);
	}

	a = GG(a, b, c, d, M[3], 3); 
	d = GG(d, a, b, c, M[7], 5); 
	c = GG(c, d, a, b, M[11], 9); 
	b = GG(b, c, d, a, M[15], 13); 

	// implication encoding: S[24] -> !a, S[25] -> !d, S[26] -> !c, S[27] -> !b
	for(i = 0; i < 32; i = i + 1)
	{
		assert(!S[24] | !a[i]);
		assert(!S[25] | !d[i]);
		assert(!S[26] | !c[i]);
		assert(!S[27] | !b[i]);
	}

	// Steps from 33--39
	a = HH(a, b, c, d, M[0], 3); 
	d = HH(d, a, b, c, M[8], 9); 
	c = HH(c, d, a, b, M[4], 11); 
	b = HH(b, c, d, a, M[12], 15); 

	// implication encoding: S[28] -> !a, S[29] -> !d, S[30] -> !c
	for(i = 0; i < 32; i = i + 1)
	{
		assert(!S[28] | !a[i]);
		assert(!S[29] | !d[i]);
		assert(!S[30] | !c[i]);
	}

	a = HH(a, b, c, d, M[2], 3);   
	d = HH(d, a, b, c, M[10], 9);  
	c = HH(c, d, a, b, M[6], 11);

	
	Hash[0] = a;
	Hash[1] = b;
	Hash[2] = c;
	Hash[3] = d;

	// zero hash:
	//assert (!Hash);

	// set of switching variables
	core_var(S);
}